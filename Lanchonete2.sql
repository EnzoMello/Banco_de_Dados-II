CREATE TABLE CLIENTE (
	COD_CLI SERIAL PRIMARY KEY,
	NOME VARCHAR(30)
);

CREATE TABLE VENDA (
	COD_VENDA SERIAL PRIMARY KEY,
	COD_CLI INT REFERENCES CLIENTE(COD_CLI),
	VALOR_TOTAL FLOAT,
	DT_VENDA DATE
);

CREATE TABLE ITEM_VENDA (
	COD_PROD INT REFERENCES PRODUTO(COD_PROD),
	COD_VENDA INT REFERENCES VENDA(COD_VENDA),
	QUANT_VENDIDA INT
);

CREATE TABLE PRODUTO (
	COD_PROD SERIAL PRIMARY KEY,
	VALOR FLOAT,
	NOME VARCHAR(30),
	QUANT INT
);

CREATE TABLE COMBO (
	COD_PROD_COMBO INT NOT NULL REFERENCES PRODUTO(COD_PROD),
	QUANT INT,
	COD_PRODUTO_COMP INT NOT NULL REFERENCES PRODUTO(COD_PROD),
	PRIMARY KEY (COD_PROD_COMBO, COD_PRODUTO_COMP)
);

INSERT INTO CLIENTE(NOME) VALUES
('Alice'),
('Bruno'),
('Carla'),
('Diego');

INSERT INTO PRODUTO(VALOR,NOME,QUANT) VALUES
(10.50, 'Caneta Azul', 100),
(5.00,  'L√°pis Preto', 200),
(15.90, 'Caderno 100 folhas', 150),
(3.20,  'Borracha', 300),
(8.00,  'R√©gua 30cm', 180),
(14.00, 'Caneta + Lapis Preto', 100),
(34.90, 'Caderno + Caneta + Lapis', 100);

INSERT INTO VENDA(COD_CLI, VALOR_TOTAL, DT_VENDA) VALUES
(1, 41.90, '2025-05-10'),
(2, 13.20, '2025-05-11');

INSERT INTO ITEM_VENDA(COD_PROD, COD_VENDA, QUANT_VENDIDA) VALUES
(3, 1, 2),  -- 2 x Caderno 100 folhas (15.90)
(1, 1, 1),  -- 1 x Caneta Azul (10.50)
(5, 2, 1),  -- 1 x R√©gua 30cm (8.00)
(4, 2, 2);  -- 2 x Borracha (3.20)

INSERT INTO COMBO (cod_prod_combo, COD_PRODUTO_COMP, QUANT) VALUES 
(6, 3, 1),  -- 1x Caderno + 2x Caneta + 1x Lapis
(6, 1, 2),  -- 1x Caderno + 2x Caneta + 1x Lapis
(6, 2, 1),  -- 1x Caderno + 2x Caneta + 1x Lapis
(7, 1, 1),  -- 1x Caneta Azul + 2x Lapis Preto
(7, 2, 2);  -- 1x Caneta Azul + 2x Lapis Preto

-- üìå TRIGGERS (8 Quest√µes)
-- 1 - Crie uma trigger que impe√ßa que o valor de `quant` (estoque) de qualquer produto fique abaixo de zero ap√≥s uma atualiza√ß√£o.
CREATE OR REPLACE TRIGGER TRG_IMPEDIR_ESTOQUE
BEFORE UPDATE ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_IMPEDE_ESTOQUE();

CREATE OR REPLACE FUNCTION TG_IMPEDE_ESTOQUE()
RETURNS TRIGGER AS $$
BEGIN 

IF (NEW.QUANT < 0) THEN
	RAISE EXCEPTION 'Um estoque de um produto n√£o pode ficar abaixo de zero.';
END IF;

RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;

-- 2 - Implemente uma trigger que registre em uma tabela de auditoria (`AUDITORIA_PRECO`) sempre que o valor (`valor`) de um produto for alterado. Armazene: `cod_prod`, `valor_antigo`, `valor_novo`, `data_modificacao`.
CREATE TABLE AUDITORIA_PRECO (
	COD_PROD INT NOT NULL,
	VALOR_ANTIGO FLOAT,
	VALOR_NOVO FLOAT,
	DATA_MODIFICACAO TIMESTAMP
);

CREATE OR REPLACE TRIGGER TRG_REGISTRA_AUDITORIA
AFTER UPDATE ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_REGISTRAR_AUDITORIA();

CREATE OR REPLACE FUNCTION TG_REGISTRAR_AUDITORIA()
RETURNS TRIGGER AS $$
BEGIN 

IF (NEW.VALOR <> OLD.VALOR) THEN
	INSERT INTO AUDITORIA_PRECO VALUES
	(NEW.COD_PROD, OLD.VALOR, NEW.VALOR, CURRENT_TIMESTAMP);
	RETURN NEW;

END IF;
END;
$$
LANGUAGE PLPGSQL;
	
-- 3 - Crie uma trigger que atualize automaticamente o `valor_total` da tabela `VENDA` sempre que um item for inserido ou alterado na tabela `ITEM_VENDA`.
CREATE OR REPLACE TRIGGER TRG_ATUALIZA_VALOR_TOTAL
AFTER INSERT OR UPDATE ON ITEM_VENDA
FOR EACH ROW EXECUTE PROCEDURE TG_ATUALIZAR_VALOR_TOTAL();

CREATE OR REPLACE FUNCTION TG_ATUALIZAR_VALOR_TOTAL()
RETURNS TRIGGER AS $$
BEGIN 

IF (NEW.VALOR_TOTAL <> OLD.VALOR_TOTAL) THEN
	UPDATE VENDA
	SET VALOR_TOTAL = NEW.VALOR_TOTAL;
	RETURN NEW;

END IF;
END;
$$
LANGUAGE PLPGSQL;

-- 4 - Implemente uma trigger que aplique 10% de desconto no valor do produto quando ele for um combo (ou seja, aparece como `cod_prod_combo` na tabela `COMBO`).
CREATE OR REPLACE TRIGGER TRG_APLICA_DESCONTO
BEFORE INSERT ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_APLICAR_DESCONTO();

CREATE OR REPLACE FUNCTION TG_APLICAR_DESCONTO()
RETURNS TRIGGER AS $$
BEGIN 

IF EXISTS (SELECT * FROM COMBO WHERE COD_PROD_COMBO = NEW.COD_PROD) THEN
	NEW.COD_PROD = NEW.COD_PROD * 0.90;
	RETURN NEW;

END IF;
END;
$$
LANGUAGE PLPGSQL;

-- 5 - Crie uma trigger que impe√ßa a exclus√£o ou altera√ß√£o dos produtos que fazem parte de algum combo (`cod_produto_comp`).
CREATE OR REPLACE TRIGGER TRG_IMPEDE_DELETE_UPDATE
BEFORE DELETE OR UPDATE ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_IMPEDIR_DELETE_UPDATE();

CREATE OR REPLACE FUNCTION TG_IMPEDIR_DELETE_UPDATE()
RETURNS TRIGGER AS $$
BEGIN 

	IF EXISTS(SELECT * FROM COMBO WHERE COD_PRODUTO_COMP = NEW.COD_PROD)) THEN
		RAISE EXCEPTION 'N√£o √© poss√≠vel fazer a exclus√£o ou altera√ß√£o de produtos que fazem parte de combo';
	END IF;

RETURN OLD;
END;
$$
LANGUAGE PLPGSQL;

-- 6 - Crie uma trigger que, ao aumentar o estoque de um combo, **aumenta proporcionalmente o estoque de seus componentes** (se poss√≠vel).
CREATE OR REPLACE TRIGGER TRG_AUMENTAR_ESTOQUE_COMBO
AFTER UPDATE ON COMBO
FOR EACH ROW EXECUTE PROCEDURE TG_AUMENTAR_ESTOQUE_COMBO();

CREATE OR REPLACE FUNCTION TG_AUMENTAR_ESTOQUE_COMBO()
RETURNS TRIGGER AS $$
DECLARE
	DIFERENCA INT;
BEGIN 

	DIFERENCA := NEW.QUANT - OLD.QUANT;

	IF DIFERENCA > 0 THEN
		UPDATE PRODUTO
		SET QUANT = QUANT + (DIFERENCA * NEW.QUANT)
		WHERE COD_PROD = NEW.COD_PRODUTO_COMP;
	END IF;
	RETURN NEW;
	

END;
$$
LANGUAGE PLPGSQL;

-- 7 - Crie uma trigger que, ao inserir uma nova venda (`VENDA`), atualize uma coluna `qtd_vendas` na tabela `CLIENTE`.
ALTER TABLE CLIENTE
ADD COLUMN QTD_VENDAS INT DEFAULT 0;

CREATE OR REPLACE TRIGGER TRG_ATUALIZA_QTD_VENDAS_CLIENTE
AFTER INSERT ON VENDA
FOR EACH ROW EXECUTE PROCEDURE TG_ATUALIZAR_VENDAS_CLIENTE();

CREATE OR REPLACE FUNCTION TG_ATUALIZAR_VENDAS_CLIENTE()
RETURNS TRIGGER AS $$
BEGIN 

	UPDATE CLIENTE
	SET CLIENTE.QTD_VENDAS = CLIENTE.QTD_VENDAS + 1
	WHERE COD_CLI = NEW.COD_CLI;
	RETURN NEW;

END;
$$
LANGUAGE PLPGSQL;

-- 8 - Crie uma trigger que **impede inser√ß√£o em `ITEM_VENDA`** se a quantidade vendida ultrapassar o estoque dispon√≠vel do produto (considerando que combos j√° afetam o estoque).
CREATE OR REPLACE TRIGGER TRF_IMPEDE_ITEM_VENDA
BEFORE INSERT ON ITEM_VENDA
FOR EACH ROW EXECUTE PROCEDURE TG_IMPEDIR_ITEM_VENDA();

CREATE OR REPLACE FUNCTION TG_IMPEDIR_ITEM_VENDA()
RETURNS TRIGGER AS $$
BEGIN

	IF (NEW.QUANT > PRODUTO.QUANT) THEN
		RAISE EXCEPTION 'A quantidade vendida ultrapassou o estoque dispon√≠vel.';
	END IF;

RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;
